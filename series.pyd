import math, time
e, pi, sin, cos, tan = math.e, math.pi, math.sin, math.cos, math.tan

def f(t):
    l = [-1 -1j, 0 -1j, 1 - 1j, 1 + 0j, 1 + 1j, 0 + 1j, -1 + 1j, -1 + 0j]
    return l[int(t * len(l))]

    t = t * 2 * pi
    # return complex((sin(t))/(max(abs(cos(t)),abs(sin(t)))), (cos(t))/(max(abs(cos(t)),abs(sin(t)))))
    # return complex(t - pi, t - pi)
    # return complex((t - pi) / pi, sin(3 * t))
    # return complex((16*math.sin(t)**(3)),(13*math.cos(t)-5*math.cos(2*t)-2*math.cos(3*t)-math.cos(4*t)))
    # return complex(sin(5 * t), cos(3 * t))

def getC(c):
    r = 0
    step = 0.001
    t = 0
    while t < 1:
        r += step * f(t) * (e ** (-c * 2.0 * pi * 1j * t))
        t += step
        
    return r

def setup():
    global coefs, backdrop, x, y, timer, timerV, centered, resetTimer, lastVertex, colorer
    fullScreen(P3D)
    noSmooth()
    frameRate(240)
    background(0)
    colorer = loadShader("circle.glsl")
    backdrop = createShape()

    lastVertex = (-10**10, -10**10)
    centered = False
    timer, timerV = 0, 0.05
    resetTimer = 0
    t1 = time.time()
    coefs = [(i, getC(i)) for i in range(-500, 500, 1)]
    print(round(time.time() - t1, 3))
    x, y = width / 2, height / 2

def draw():
    global x, y, timer, timerV, centered, lastVertex
    sc = max(1.0, float(mouseX ** 2 / 10))

    background(0)
    backdrop.disableStyle()
    backdrop.beginShape()
    backdrop.stroke(255)
    backdrop.noFill()
    for tick in range(5, -1, -1):
        cs = []
        timer += timerV / frameRate
        x, y = 0, 0
        for index, v in coefs:
            c = v * (e ** (index * 2.0 * pi * 1j * timer))
            c = complex(c.real, -c.imag) #flip imaginary because cartesian VS computer coordinates
            cs.append((x, y, x + c.real, y + c.imag))
            x, y = x + c.real, y + c.imag

        # if tick == 0:
        #     background(0)
        #     stroke(85, 85, 255)
        #     strokeWeight(2.0 / sc)
        #     pushMatrix()
        #     translate(width / 2.0, height / 2.0)
        #     scale(sc)
        #     translate(0 if centered else -x, 0 if centered else -y)
        #     for i in cs:
        #         line(i[0], i[1], i[2], i[3])
        #     popMatrix()

        if timer - resetTimer <= 1.25 and dist(lastVertex[0], lastVertex[1], x, y) >= 0.01 / sc: 
            backdrop.vertex(x, y)
            lastVertex = (x, y)
    backdrop.endShape()
    
    pushMatrix()
    translate(width / 2, height / 2)
    scale(sc)
    noFill()
    strokeWeight(4.0)
    stroke(255)
    shape(backdrop, 0 if centered else -x, 0 if centered else -y)
    popMatrix()
    colorer.set("loc", (0.0 if centered else x * sc) - width / 2.0, (0.0 if centered else -y * sc) - height / 2.0)
    filter(colorer)
    
    stroke(85, 85, 255)
    strokeWeight(2.0 / sc)
    pushMatrix()
    translate(width / 2.0, height / 2.0)
    scale(sc)
    translate(0 if centered else -x, 0 if centered else -y)
    for i in cs:
        line(i[0], i[1], i[2], i[3])
    popMatrix()

    textSize(24)
    text("Speed: " + "%.15f" % timerV + '\nCentered: ' + str(centered), 20, 20)
    ellipse(width / 2, height / 2, 3, 3)

def mouseClicked():
    global centered
    if mouseButton == LEFT:
        centered = not centered

def keyPressed():
    global backdrop, timerV, resetTimer
    if keyCode == RIGHT:
        timerV *= 2.0
    if keyCode == LEFT:
        timerV /= 2.0
    if keyCode == 32:
        backdrop = createShape()
        resetTimer = time.time()